<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Morty">





<title>BUAA-OO-第一单元： 表达式展开 | Morty&#39;s Dimension</title>



    <link rel="icon" href="/morty_4Hk_2.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Morty&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Morty&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">BUAA-OO-第一单元： 表达式展开</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Morty</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 15, 2025&nbsp;&nbsp;20:56:30</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象编程</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一单元的主题是<strong>表达式展开</strong>，主要目的是熟悉面向对象的思想，学会使用类来管理对象。本单元包括三次作业———<strong>单变量多项式展开，含有三角函数和自定义递归函数的多项式展开，含有求导因子和自定义函数的多项式展开</strong>。</p>
<p>这三次作业的要求是<strong>层层递进</strong>的，一个好的框架是最重要的。在这篇博客中，我将对这三次作业的代码进行分析，对本人的学习心得体会进行总结。</p>
<h1 id="第一次作业分析"><a href="#第一次作业分析" class="headerlink" title="第一次作业分析"></a>第一次作业分析</h1><p>第一次作业是关于单变量多项式的展开，在这一作业中，主要的难点是<strong>幂函数，表达式因子</strong>的展开。</p>
<h2 id="代码UML类图"><a href="#代码UML类图" class="headerlink" title="代码UML类图"></a>代码UML类图</h2><p>本次作业的UML类图如图所示：</p>
<h2 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expr   = Term   | Term   [+|-] Expr</span><br><span class="line">Term   = Factor | Factor [*] Term</span><br><span class="line">Factor = Var    | Num    | PowerFactor  | ExprFactor</span><br></pre></td></tr></table></figure>

<p>分析这次作业的要求后，我们可以将表达式按层分为三部分：<code>Expr</code>,<code>Term</code> ,<code>Factor</code>。<code>Factor</code>类型中又可以分出———<code>PowFactor</code>,<code>Var</code>,<code>Num</code>。基于面向对象的思想，我们要对这些类型分别建类。在<code>Expr</code>类型中使<code>ArrayList</code>来包含表达式所含有的所有<code>Term</code>，同时在<code>Term</code>中使用<code>ArrayList</code>来包含其项中所拥有的所用<code>Factor</code>。</p>
<p>本次作业中主要有两个问题：</p>
<p><strong>·如何对将表达式，项和因子解析出来？</strong><br><strong>·如何将表达式展开并输出？</strong></p>
<h3 id="预处理-表达式解析"><a href="#预处理-表达式解析" class="headerlink" title="预处理+表达式解析"></a>预处理+表达式解析</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>在输入中，获得的表达式会有多余的空格和制表符，连续重复的正负号，我们要在预处理中将这些问题解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// MainClass.java</span><br><span class="line">public class MainClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String input = scanner.nextLine();</span><br><span class="line">        // 获得预处理后的字符串</span><br><span class="line">        String afterProcess = processor.mergeSymbols(processor.removeSpaces(input));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Processor.java</span><br><span class="line">public class Processor &#123;</span><br><span class="line">    // 去除空格和制表符</span><br><span class="line">    public String removeSpaces(String input) &#123;&#125;</span><br><span class="line">    // 合并&#x27;+&#x27;&#x27;-&#x27;,为了保证格式一致，可以在表达式因子第一项前添加符号</span><br><span class="line">    public String mergeSymbols(String input) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一个小技巧是在表达式因子第一项前加上符号，保证格式的一致性，便于表达式的解析</p>
<h4 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h4><p>在本次作业中，我使用了<strong>递归下降算法</strong>，它主要包含了两个部分：<code>Lexer</code>(词法分析器)和<code>Paser</code>(解析器)。</p>
<p><code>Lexer</code>的主要目标是将表达式分解为一系列我们定义的基本语法单元，<code>Paser</code>通过<code>Lexer</code>解析出的基本语法单元递归的生成表达式，项和因子。可以打个比方，<code>Lexer</code>就是“眼睛”，可以让我们“看”到表达式，<code>Paser</code>是“大脑”，对表达式进行分析。</p>
<h5 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h5><p>在本次作业中有<code>ADD,MIN,MUL,POW,NUM,VAR,LP,RP</code>等基本语法类型，我们使用<code>Type</code>这一枚举类型来记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Type &#123;</span><br><span class="line">        ADD, MIN, MUL, POW,</span><br><span class="line">        NUM, VAR,</span><br><span class="line">        LP, RP,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们遍历整个表达式，将遍历出的<strong>基本语法类型</strong>存入<code>ArrayList&lt;Token&gt; tokens</code>中———</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void classify() &#123;</span><br><span class="line">        while (pos &lt; input.length()) &#123;</span><br><span class="line">            if (input.charAt(pos) == &#x27;+&#x27;) &#123;</span><br><span class="line">                tokens.add(new Token(Token.Type.ADD, &quot;+&quot;));</span><br><span class="line">                pos++;</span><br><span class="line">            &#125; else if (input.charAt(pos) == &#x27;-&#x27;) &#123;</span><br><span class="line">            // do something;  </span><br><span class="line">            &#125; </span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样我们就把所有基本语法单元都解析出来了，接下来将使用<code>Parser</code>进行表达式分析。</p>
<h4 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h4><p>在本次作业中，我们可以将表达式解析成三个部分<code>parseExpr</code>,<code>parseTerm</code>,<code>parseFactor</code>，以解析<code>parseExpr</code>为例:<code>parseExpr</code>实际上是由<code>parseTerm</code>以加减号连接起来的，我们可以使用<code>while</code>循环，先解析每一项前的加减号，然后再调用解析项的方法。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Expr parseExpr() &#123;</span><br><span class="line">        Expr expr = new Expr();</span><br><span class="line">        int termSign = 1;</span><br><span class="line">        // 获得第一项的符号</span><br><span class="line">        if (lexer.getCurToken().getType() == Token.Type.MIN) &#123;</span><br><span class="line">            termSign = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.nextToken();</span><br><span class="line">        expr.addTerm(parseTerm(termSign));</span><br><span class="line">        // 获得下一项，直到表达式的末位</span><br><span class="line">        while (!lexer.isEnd()</span><br><span class="line">                &amp;&amp; (lexer.getCurToken().getType() == Token.Type.ADD</span><br><span class="line">                || lexer.getCurToken().getType() == Token.Type.MIN)) &#123;</span><br><span class="line">            if (lexer.getCurToken().getType() == Token.Type.ADD) &#123;</span><br><span class="line">                lexer.nextToken();</span><br><span class="line">                expr.addTerm(parseTerm(1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                lexer.nextToken();</span><br><span class="line">                expr.addTerm(parseTerm(-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return expr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public Term parseTerm(int termSign) &#123;&#125;</span><br><span class="line">public Factor parceFactor() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在最底层，我们使用<code>Num</code>,<code>Var</code>,<code>PowFactor</code>获得最基本的因子。使用<strong>递归下降法</strong>的一个好处是当我们遇到了表达式因子后，只需要跳过<strong>括号</strong>，调用<code>parseExpr</code>即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">else &#123;  // 解析形如(x^2+1)的表达式因子</span><br><span class="line">        // 跳过左括号</span><br><span class="line">        lexer.nextToken();</span><br><span class="line">        // 调用`parseExpr`</span><br><span class="line">        Expr newExpr = parseExpr();</span><br><span class="line">        // 跳过右括号</span><br><span class="line">        lexer.nextToken();</span><br><span class="line">        // 返回表达式因子</span><br><span class="line">        return newExpr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="表达式展开"><a href="#表达式展开" class="headerlink" title="表达式展开"></a>表达式展开</h3><p>经过分析可以发现，表达式最终要展开为下面这种形式：</p>
<p>$$<br>Expr &#x3D; \sum a_i x^{n_i}<br>$$</p>
<p>可以发现<strong>多项式</strong>中包含多个形如$ a_i x^{n_i}$的单项式。因此我们新创建两个类———<code>Poly</code>(多项式类),<code>Unit</code>(单项式类，考虑到迭代的要求，这里命名为Unit)。</p>
<p><strong>·</strong> Unit类中有两个变量——<code>coe</code>,<code>exp</code>分别代表单项式的<strong>系数</strong>和<strong>x的指数</strong>，同时可以使用<code>toPoly()</code>转换为<strong>coe*x^exp</strong>的形式。</p>
<p><strong>·</strong> Poly类中有一个<code>ArrayList</code>容器来存储所有的<code>Unit</code>,同时还有<code>addPoly()</code>,<code>mulPoly()</code>,<code>powPoly()</code>等方法来实现多项式之间的运算，最后通过<code>printPoly()</code>以字符串形式输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Poly &#123;</span><br><span class="line">    public Poly addPoly(Poly newPoly) &#123;&#125;</span><br><span class="line">    public Poly mulPoly(Poly newPoly) &#123;&#125;</span><br><span class="line">    public Poly powPoly(int n) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们只需要在我们之前设立的<code>Expr</code>,<code>Term</code>,<code>Factor</code>类中都实现<code>toPoly()</code>方法,将类中的内容转换为多项式就好。这里也可以使用<strong>递归下降</strong>的方法：如<code>Expr</code>类型的转换就是将所有它包含的<code>Term</code>类型的<code>Poly</code>形式（即<code>toPoly()</code>的结果）加减起来；<code>Term</code>类的<code>toPoly()</code>方法是将该类中含有的所有<code>Factor</code>的<code>Poly</code>形式用<code>mulPoly()</code>方法乘起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Expr.java</span><br><span class="line"> public Poly toPoly() &#123;</span><br><span class="line">        for (Term term : terms) &#123;</span><br><span class="line">            if (term.returnSign() == 1) &#123;</span><br><span class="line">                ans = ans.addPoly(term.toPoly());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = ans.subPoly(term.toPoly());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">// Term.java</span><br><span class="line">public Poly toPoly() &#123;</span><br><span class="line">        Poly ans = factors.get(0).toPoly();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; factors.size(); i++) &#123;</span><br><span class="line">            ans = ans.mulPoly(factors.get(i).toPoly());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最底层的Factor可以分类后分别编写<code>toPoly()</code>方法：<br><code>Num</code>(数字因子)和<code>Var</code>（幂函数因子）的<code>toPoly</code>方法很简单，直接转化为只含有一个<code>Unit</code>的<code>Poly</code> 即可。例如，因子<code>5</code>可以转化为一个只含有单项式<code>5*x^0的</code>多项式，因子<code>x^2</code>一个只含有单项式<code>1*x^2</code>的多项式。<br>形如<code>(x^2+x+2)^4</code>的表达式因子来说，<code>Expr</code>类型的“底”和一个<code>int</code>类型的指数，我们可以通过<code>expr.toPoly()</code>得到 “底”的多项式形式，然后使用<code>powPoly()</code>方法展开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// PowFactor.java</span><br><span class="line">public Poly toPoly() &#123;</span><br><span class="line">        Poly result = base.toPoly();</span><br><span class="line"></span><br><span class="line">        result = result.powPoly(exp.intValue());</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，我们就可以通过在每个类中定义的<code>toPoly(</code>)方法<strong>自底向上</strong>地得到表达式的多项式形式。最后通过字符串形式输出。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>本次作业的性能分是依据输出的字符串长度来赋分，所以对于系数为<code>1</code>或<code>-1</code>的项，我们不会输出系数。同时指数为<code>0</code>或<code>1</code>时，应当输出常数和<code>x</code>，而不是<code>x^0</code>,<code>x^1</code>。<br>最后，当输出的首项为负数时，我们可以将这一项向后移，换一个正项在前，这样也可以节省一个字符。</p>
<h1 id="第二次作业分析"><a href="#第二次作业分析" class="headerlink" title="第二次作业分析"></a>第二次作业分析</h1><p>第二次作业在第一次作业的基础上加入了<strong>三角函数</strong>和<strong>自定义递归函数</strong>，复杂度较上一次进一步提高。<br>自定义递归函数形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f&#123;0&#125;(y) = y</span><br><span class="line">f&#123;1&#125;(y) = 1</span><br><span class="line">f&#123;n&#125;(y) = 1*f&#123;n-1&#125;(sin(y)) - 4*f&#123;n-2&#125;(y^2) + 1</span><br><span class="line">///////////////////////////////////////////////</span><br><span class="line">f&#123;0&#125;(x, y) = x - y</span><br><span class="line">f&#123;n&#125;(x, y) = 0*f&#123;n-1&#125;(x, y) + 35*f&#123;n-2&#125;(x, y^2)</span><br><span class="line">f&#123;1&#125;(x, y) = x^3 + y</span><br></pre></td></tr></table></figure>

<h2 id="代码UML类图-1"><a href="#代码UML类图-1" class="headerlink" title="代码UML类图"></a>代码UML类图</h2><p>本次代买的UML类图如下所示：</p>
<h2 id="代码架构分析-1"><a href="#代码架构分析-1" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><p>在这次作业中，仍然可以使用<strong>递归下降法</strong>，只需要添加几种<strong>基本语法单元</strong>：<code>SIN</code>,<code>COS</code>,<code>FUNC</code>, <code>COMMA</code>,本次作业的主要难点如下：</p>
<p><strong>·<strong>如何解析</strong>三角函数</strong>？<br><strong>·<strong>如何展开</strong>自定义递归函数</strong>？如何将实参带入函数定义式中去？</p>
<h3 id="三角函数的解析"><a href="#三角函数的解析" class="headerlink" title="三角函数的解析"></a>三角函数的解析</h3><p>在本次作业中，我们可以新建两个新的类：<code>SinFactor</code>和<code>CosFactor</code>,类中都有两个成员变量：<strong>Core</strong>(三角函数括号内的内容)，<strong>exp</strong>(三角函数的指数部分)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CosFactor.java</span><br><span class="line">public class CosFactor implements Factor &#123;</span><br><span class="line">    private Factor cosCore;</span><br><span class="line">    private BigInteger exp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们在Paser中添加了<code>parseSinFactor</code>和<code>parseCosFactor</code>两个新的方法。当我们发现当前解析的基本语法单元式是<code>sin</code>或<code>cos</code>时，就调用这两种方法，然后将结果保存在<code>SinFactor</code>对象或<code>CosFactor</code>对象返回即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Parser.java</span><br><span class="line">public CosFactor parseCosFactor() &#123;</span><br><span class="line">        ......</span><br><span class="line">        Factor cosCore = parseExpr();</span><br><span class="line">        .......</span><br><span class="line">        CosFactor newCos = new CosFactor(cosCore,...);</span><br><span class="line">        return newCos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义递归函数"><a href="#自定义递归函数" class="headerlink" title="自定义递归函数"></a>自定义递归函数</h3><p>为了方便管理和解析自定义函数，我新建了一个<code>Define</code>工具类，主要负责<strong>自定义函数的定义和调用</strong>。这是一个静态类，所以我们在使用时不需要实例化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static ArrayList&lt;String&gt; Formal = new ArrayList&lt;&gt;();</span><br><span class="line">private static HashMap&lt;String, String&gt; Expression = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>这个函数该函数有两个主要的私有静态成员<code>Formal</code>和<code>Expression</code>，前者者可以获得该函数的形参列表（<code>x/y</code>）,后者可以通过函数名（<code>f/g/h</code>）来获得函数的定义式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Define.java</span><br><span class="line">public static void getFormal(String expr) &#123;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    while (expr.charAt(pos) != &#x27;x&#x27; &amp;&amp; expr.charAt(pos) != &#x27;y&#x27;) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">    Formal.add(String.valueOf(expr.charAt(pos)));</span><br><span class="line">    while (expr.charAt(pos) != &#x27;)&#x27;) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void addFunc(String expr) &#123;</span><br><span class="line">    String[] parts = expr.split(&quot;=&quot;);</span><br><span class="line">    String left = parts[0].trim();</span><br><span class="line">    String right = parts[1].trim();</span><br><span class="line"></span><br><span class="line">    if (left.startsWith(&quot;f&#123;0&#125;&quot;)) &#123;</span><br><span class="line">        Expression.put(&quot;0&quot;, right);</span><br><span class="line">    &#125; else if (left.startsWith(&quot;f&#123;1&#125;&quot;)) &#123;</span><br><span class="line">        Expression.put(&quot;1&quot;, right);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Expression.put(&quot;n&quot;, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就就获得了我们解析函数所需要的信息。接下来要处理函数调用机制：我们要考虑的有以下几点：</p>
<p><strong>·</strong> <strong>实参与形参分离</strong>：通过<code>assignment</code>哈希表实现参数映射，实现形参（函数定义时的参数名）与相对实参（调用时传入的具体因子）的对应关系。<br><strong>·</strong> <strong>递归替换</strong>：通过<code>assign</code>方法逐层展开函数调用。<br><strong>.</strong> <strong>终止条件</strong>：当递归到初始定义表达式时完成解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// FuncFactor.java</span><br><span class="line">public class FuncFactor implements Factor &#123;</span><br><span class="line">    private HashMap&lt;String, Factor&gt; assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>FuncFactor</code>中加入<code>HashMap&lt;String, Factor&gt; assignment</code>，用来记录实参和形参的对应关系。在实现的<code>assign</code>方法中作为传入参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// FuncFactor.java</span><br><span class="line">public Factor assign(HashMap&lt;String, Factor&gt; assignment) &#123;</span><br><span class="line">        return Define.get(this.index).assign(this.assignment).assign(assignment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在<code>FuncFactor</code>中调用<code>assign</code>方法来实现<strong>递归替换</strong>，我们接下来来解析这个方法。<br><code>Define</code>类中有一个<code>get</code>方法，返回一个以函数表达式为基础的<code>Parser</code>类，我们接下来的操作在这个基础上进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Define.java</span><br><span class="line">public static Expr get(String index) &#123;</span><br><span class="line">        Processor processor = new Processor();</span><br><span class="line">        String func0 = processor.mergeSymbols(processor.removeSpaces(Expression.get(&quot;0&quot;)));</span><br><span class="line">        String func1 = processor.mergeSymbols(processor.removeSpaces(Expression.get(&quot;1&quot;)));</span><br><span class="line">        String funcN = processor.mergeSymbols(processor.removeSpaces(Expression.get(&quot;n&quot;)));</span><br><span class="line">        if (index.equals(&quot;0&quot;)) &#123;</span><br><span class="line">            Lexer lexer = new Lexer(func0);</span><br><span class="line">            Parser parser = new Parser(lexer);</span><br><span class="line">            return parser.parseExpr();</span><br><span class="line">        &#125; </span><br><span class="line">        .......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String func5 = funcN.replaceAll(&quot;n-1&quot;, &quot;4&quot;);</span><br><span class="line">            func5 = func5.replaceAll(&quot;n-2&quot;, &quot;3&quot;);</span><br><span class="line">            Lexer lexer = new Lexer(func5);</span><br><span class="line">            Parser parser = new Parser(lexer);</span><br><span class="line">            return parser.parseExpr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这之后我们连续调用两次<code>assign</code>方法，要注意这两个<code>assign</code>方法传入的<code>assignment</code>是不同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.assign(this.assignment)</span><br><span class="line">// 先应用this.assignment当前层的参数绑定，向下查看是否还需要继续替换</span><br><span class="line">.assign(assignment);</span><br><span class="line">// 再应用外层传入的assignment参数，实现参数作用域的嵌套覆盖</span><br></pre></td></tr></table></figure>

<p>简单来说，第一个<code>assign</code>是为了向下递归，如果此时还包含有函数因子，则继续替换，第二个<code>assign</code>用来返回，将这一层得到的结果向上返回,用于得到最后的表达式形式。</p>
<p>最后，我们在每一个类中都实现<code>assign</code>方法，然后在<code>Expr</code>类中调用 <code>expr = expr.assign(null);</code>来启动替换（参数<code>null</code>代表此时最上层表达式中的参数为绝对实参）</p>
<p>经过上面的处理，我们的表达式中就不会含有函数因子了，可以使用<code>toPoly()</code>方法转换为多项式了。</p>
<h3 id="表达式展开-1"><a href="#表达式展开-1" class="headerlink" title="表达式展开"></a>表达式展开</h3><p>在这一次作业中，我们跟新<code>Unit</code>包含的最小单元：<br>$$<br>a x^n \prod_{i} \sin(\text{Factor}<em>i) \prod</em>{i} \cos(\text{Factor}_i)<br>$$</p>
<p>所以我们能将数据组成做出一定的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private BigInteger coe;</span><br><span class="line">private BigInteger exp;</span><br><span class="line">private HashMap&lt;Poly, BigInteger&gt; sinMap;</span><br><span class="line">private HashMap&lt;Poly, BigInteger&gt; cosMap;</span><br></pre></td></tr></table></figure>

<p>其中<code>sinMap</code>和<code>cosMap</code>是用来存储这个最小单元的三角函数。<code>Hashmap</code>的<code>key</code>是三角函数括号里的表达式，<code>value</code>是三角函数指数。在<code>Poly</code>中，我们仍然使用一个<code>ArrayList</code>来存放它下属的各个<code>Unit</code>，因为<code>Unit</code>结构的改变, <code>mulPoly()</code>, <code>addPoly()</code>, <code>powPoly()</code>等函数的实现细节也需要进行一定的修改。有一个点需要注意：我们要返回深克隆的对象，否则会出现重复调用等不可靠控的bug。</p>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>三角函数中少不了合并同类项的步骤，为了识别同类项，我们需要在<code>Unit</code>中重写<code>equals()</code>和<code>hashCode()</code>方法，这是因为我们使用了自定义类作为<code>HashMap</code>的<code>Value</code>值。同时注意<code>equals()</code>方法重写时，不需要比较<code>coe</code>。</p>
<h1 id="第三次作业分析"><a href="#第三次作业分析" class="headerlink" title="第三次作业分析"></a>第三次作业分析</h1><p>这一次作业中，添加了<strong>自定义函数</strong>和<strong>求导因子</strong>。虽然听起来感觉很复杂，但只要掌握好了<strong>递归下降</strong>的方法，我们都可以轻松解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 自定义函数样例</span><br><span class="line">g(x) = h(x) + 6</span><br><span class="line">h(x) = g(x) * sin(x)</span><br><span class="line">// 最终输入样例</span><br><span class="line">1</span><br><span class="line">g(x,y)=x*y</span><br><span class="line">1</span><br><span class="line">f&#123;0&#125;(x)=x^2</span><br><span class="line">f&#123;1&#125;(x)=1</span><br><span class="line">f&#123;n&#125;(x)=2*f&#123;n-1&#125;(x^2)+3*f&#123;n-2&#125;(x^3)+-1</span><br><span class="line">g(f&#123;2&#125;(x),dx(x^2))</span><br></pre></td></tr></table></figure>

<h2 id="代码UML类图-2"><a href="#代码UML类图-2" class="headerlink" title="代码UML类图"></a>代码UML类图</h2><p>本次代码的UML类图如下所示：</p>
<h2 id="代码框架分析"><a href="#代码框架分析" class="headerlink" title="代码框架分析"></a>代码框架分析</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>自定义函数的处理十分简单，我们只需要在<code>Define</code>中加如新的函数，然后按照我们之前处理<strong>自定义递归函数</strong>一样处理就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自定义函数</span><br><span class="line">private static final ArrayList&lt;String&gt; GFormal = new ArrayList&lt;&gt;();  </span><br><span class="line">// 自定义函数</span><br><span class="line">private static final ArrayList&lt;String&gt; HFormal = new ArrayList&lt;&gt;();  </span><br><span class="line">// 解析并获得自定义函数</span><br><span class="line">public static void getSelfDefineFuncFormal(String expr) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求导因子"><a href="#求导因子" class="headerlink" title="求导因子"></a>求导因子</h3><p>求导因子初看可能会感觉很复杂，但是我们参考<strong>自定义递归函数</strong>处理方法，我们在每个类中都编写求导方法。然后自下向上获得求导的式子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Expr.java</span><br><span class="line">public Expr diff() &#123;</span><br><span class="line">    Expr exprNew = new Expr();</span><br><span class="line">    for (Term term : terms) &#123;</span><br><span class="line">        Expr diffExpr = term.diff();</span><br><span class="line">        exprNew.addExpr(diffExpr);</span><br><span class="line">    &#125;</span><br><span class="line">    return exprNew;</span><br><span class="line">&#125;</span><br><span class="line">// Term.java</span><br><span class="line">public Expr diff() &#123;</span><br><span class="line">    Expr diffExpr = new Expr();</span><br><span class="line">    for (int i = 0; i &lt; factors.size(); i++) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">    return diffExpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以<code>Expr</code>和<code>Term</code>为例，<code>Expr</code>的求导方法就是将自己包含的<code>Term</code>求导后相加，<code>Term</code>则是对包含的<code>Factor</code>求导，要注意，<code>Term</code>求导后返回的是<code>Expr</code>类型。<br>这样为每个类中都编写求导方法，结合起来我们就能获得最后的结果。</p>
<h2 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h2><p>可以考虑使用一些简单的三角函数公式进行化简，如<code>sin(x)^2+cos(x)^2=1</code>,<code>sin(0)=0</code>,<code>cos(0)=1</code>,<code>2*sin(x)*cos(x)=sin(2*x)</code>等。</p>
<h1 id="框架设计体验"><a href="#框架设计体验" class="headerlink" title="框架设计体验"></a>框架设计体验</h1><p>在这三次作业中，我在第二次作业中重构了自己的框架。一方面是为了迎合任务的需求，另一方面是为了下一次作业做准备。<br>在重构中，我也没有大改，主要得益于<strong>递归下降算法</strong>的优势。这一次作业也让我认识到了好的框架的重要性。不能仅仅着眼与眼前，要有大局观。</p>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>Unit1的强度还是很大的，一周一次的迭代作业让人感到压力很大。在陷入迷惑时，不妨查看一下往届学长的博客或和同学讨论。同时，体会到从无到有的创造也是十分有成就感的一件事。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Morty</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2025/03/15/BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%EF%BC%9A-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/">http://example.com/2025/03/15/BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%EF%BC%9A-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/OO/"># OO</a>
                    
                        <a href="/tags/Java/"># Java</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/03/15/BUAA-OS-Lab0-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/">BUAA-OS-Lab0: 基础操作</a>
            
            
            <a class="next" rel="next" href="/2025/03/14/hello-world/">Hello World</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Morty | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>